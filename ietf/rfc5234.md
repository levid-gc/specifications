#  BNF 语法规范扩充：ABNF

## 目录

* [1 介绍](#1)
* [2 规则定义](#2)
  * [2.1 规则命名](#2.1)
  * [2.2 规则格式](#2.2)
  * [2.3 终端值](#2.3)
  * [2.4 外部编码](#2.4)
* [3 操作符](#3)
  * [3.1 串联：Rule1 Rule2](#3.1)
* [6 引用](#6)
  * [6.1 标准化引用](#6.1)
  * [6.2 资料性引用](#6.2)

* [附录 B ABNF 的核心 ABNF](#appendix-B)

<br />

# <a name="1" /> 1 介绍

因特网技术规范常常需要定义一个正式的语法，并且可以自由使用作者们认为有用的任何符号。多年来。一个修改的巴科斯诺尔范式 (BNF) 版本，称为扩展的 BNF (ABNF)，已在许多因特网规范中被广泛使用。它平衡了紧凑性和简单性并具有合理的表征能力。在阿帕网 (Arpanet) 早期，每个规范都包含了各自的 ABNF 定义。这包含了 email 规范，[[RFC733](https://tools.ietf.org/html/rfc733)] 以及后来的 [[RFC822](https://tools.ietf.org/html/rfc822)]，成为了定义 ABNF 的常见引用。现在的文档将这些定义分隔开，允许选择性引用。可以预见的是，它还提供了一些修改和增强。

标准 BNF 和 ABNF 之前的区别涉及命名规则，重复 (repetition)，选择 (alternative)，顺序独立，和值范围。[附录 B](#appendix-B) 提供了对几种因特网规范常见的核心词汇分析器的规则定义和编码。它提供了便利的方式并独立于文档正文中定义的元语言，且与其正式地位相独立。

# <a name="2" /> 2 规则定义

## <a name="2.1" /> 2.1 规则命名

一个规则的名称就是很简单的名称本社，也就是一序列字符，以字母符号开始，后面接着的是任意字母，数字，和连字符（横杠）的组合。

注意：

    规则名称是大小写不敏感的。

这些名称 &lt;rulename>, &lt;Rulename>, &lt;RULENAME>, 以及 &lt;rUlENamE> 指的都是同一个规则。

与原始 BNF 不一样的是，尖括号  ("<", ">") 不是必要的。然而，当它们的存在有助于识别规则名的使用时，就可能会用到尖括号。这通常局限于在自由形式的散文中使用的规则名称引用，或者用于区分部分没有使用空白符而组成一个字符串的规则，比如在下面讨论的重复中所示。

## <a name="2.2" /> 2.2 规则格式

规则是通过以下序列定义：

    name = elements crlf

&lt;name> 是规则的名称，&lt;elements> 是一个或多个规则名称或终端 (terminal) 规范，&lt;crlf> 是行结束指示符（回车后紧跟着换行）。等于标志用于将规则的定义和名称分隔开。elements 构成了一个或多个规则名以及/或者值定义的序列，并组合了本文档中定义的各种操作符，比如选择和重复。

出于视觉考虑，规则定义是左对齐的。当一个规则需要多行的时候，后续的行是缩进的。左对齐和缩进与 ABNF 规则的首行相对，而没必要与文档的左边距相配。

## <a name="2.3" /> 2.3 终端值

规则被解析为终端值的字符串，有时也称作字符。在 ABNF 中，一个字符只是一个非负整形数字。在特定环境中，会指定值和字符集（比如 ASCII）的映射（编码）。

终端是由一个或多个数字字符指定的，这些字符的基本解释是显式的。以下的基本终端是当前定义的：


    b           =  binary

    d           =  decimal

    x           =  hexadecimal

因此：

    CR          =  %d13

    CR          =  %x0D

分别指定了 [[US-ASCII](#ref-US-ASCII)] 中回车的十进制和十六进制的表示形式。

出于紧凑性考虑，值可以组成一个串联的字符串，使用点号 (".") 在值中指示出字符的分隔。因此：


    CRLF        =  %d13.10

ABNF 允许直接使用字面量文本字符串规范，使用引号包围。因此：

    command     =  "command string"

字面量文本字符串可理解为一个串联的可打印的字符集。

注意：

    ABNF 是大小写不敏感的并且这些字符集是 US-ASCII。

因此：

    rulename = "abc"

以及：

    rulename = "aBc"

会匹配 "abc", "Abc", "aBc", "abC", "ABc", "aBC", "AbC", 和
"ABC"。

    想要指定大小写敏感的规则，那么需要单独地指定每一个字符。

举个例子：

    rulename    =  %d97 %d98 %d99

或者

    rulename    =  %d97.98.99

仅会匹配由小写形式字符组成的字符串，abc。

## <a name="2.4" /> 2.4 外部编码

因此，同样基于 ABNF 的语法可能有多种外部编码，比如一个用于 7-bit US-ASCII 环境，另一个用于二进制 8-bit 环境，使用 16-bit Unicode 的情况又有一个不一样的。编码细节已超出了 ABNF 所讨论的范围，然而附录 B 为 7-bit US-ASCII 环境提供了定义，这是因为它常见于多数因特网规范。

将语法和外部编码分隔开，目的是为了对于同样的语法可以选择使用不同的编码环境。

# <a name="3" /> 3 操作符

## <a name="3.1" /> 3.1 串联：Rule1 Rule2

通过排列一个规则名称序列，一个规则可以定义一个简单的，有序的值的字符串（比如，连续字符的串联）。举个例子：


    foo         =  %x61           ; a

    bar         =  %x62           ; b

    mumble      =  foo bar foo

因此，规则 &lt;mumble> 匹配小写字符串 "aba"。

线性空白：串联是 ABNF 解析模型的核心。连续字符（值）字符串是根据 ABNF 中定义的规则解析的。对于因特网规范，因为某些历史原因而允许线性空白（空白和水平制表符）可以自由地，隐式地散落在主要结构中，比如界定特殊字符或原子字符串

注意：

    此 ABNF 规范没有为线性空白提供隐式的规范。

任何想要允许在分隔符或字符串片段上使用线性空白的语法必须显式地指定它。在“核心”规则中提供这样的空白常常是有用的，这些规则会在更高级别的规则中使用。“核心”规则可能形成词法分析器，或者简单地成为主要规则集的一部分。


# <a name="6" /> 6 引用

## <a name="6.1" /> 6.1 标准化引用

* <a name="ref-US-ASCII" /> [US-ASCII] 美国国家标准协会，“编码字符集——7-bit 美国信息交换标准码”，ANSI X3.4，1986。

## <a name="6.2" /> 6.2 资料性引用

# <a name="appendix-B" /> 附录 B ABNF 的核心 ABNF